<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Apache Dubbo 可扩展机制分析 | 董宗磊的博客--靡不有初，鲜克有终</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="程序员, java, web, 数据库, 架构, 设计模式, 数据结构, 算法"><meta name="description" content="记录自己作为程序员的技术成长经历，程序员是个特殊的职业，一旦选择这个职业就要时刻保持学习的热情，如果你也喜欢我的博客，欢迎订阅 RSS。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://dongzl.github.io/2021/01/23/05-Java-SPI-In-Dubbo/index.html"><link rel="icon" type="image/png" href="/img/theme/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="董宗磊的博客" type="application/atom+xml"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 7.0.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/theme/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="董宗磊的博客" alt="董宗磊的博客"><img src="/img/theme/title.png" alt="董宗磊的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a target="_blank" rel="noopener" href="https://course.rs/about-book.html" alt="Rust" title="Rust">Rust</a></li><li class="nav__item"><a href="https://dongzl.github.io/netty-handbook/" alt="Netty" title="Netty">Netty</a></li><li class="nav__item"><a href="/2019/01/01/01-Excellent-Article-Link/" alt="好文链接" title="好文链接">好文链接</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/dubbo_study.png" alt="Apache Dubbo 可扩展机制分析"></div><header class="post__info"><h1 class="post__title">Apache Dubbo 可扩展机制分析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="http://dubbo.apache.org/">Apache Dubbo</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2021-01-23</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/SPI/">SPI</a></li></ul></div></div></header><div class="post__content"><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在上一篇文章 <a href="https://dongzl.github.io/2021/01/16/04-Java-Service-Provider-Interface/">Java SPI 使用及原理分析</a> 中我们通过对一些著名的 <code>Java</code> 开源框架可扩展机制的实现原理分析，引出了 <code>Java</code> <code>SPI</code> 机制，同时通过一个小的实战案例演示了 <code>Java</code> <code>SPI</code> 机制的使用方式，并结合 JDK 源码，对 <code>Java</code> <code>SPI</code> 实现原理进行了分析，最后还总结了使用原生的 <code>Java</code> <code>SPI</code> 机制可能存在的一些不足；这一篇文章中再结合 <code>Apache Dubbo</code> 开源框架，来分析一下 <code>Java</code> <code>SPI</code> 在实践场景中的应用，我们知道 Java SPI 机制还是存在一些不足的，那这些不足在 <code>Apache Dubbo</code> 框架又是如何解决的呢？</p><p>PS. 这一篇文章的内容并非原创，而是来源于 <a target="_blank" rel="noopener" href="http://dubbo.apache.org/">Apache Dubbo</a> 官网的博客文章，文章的版权属于 <code>Apache Dubbo</code>，本人只对原文部分内容进行排版和美化。</p><ul><li><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/blog/2019/04/25/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98/">Dubbo可扩展机制实战</a></p></li><li><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/blog/2019/05/02/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Dubbo可扩展机制源码解析</a></p></li></ul><h1 id="Dubbo-可扩展机制实战"><a href="#Dubbo-可扩展机制实战" class="headerlink" title="Dubbo 可扩展机制实战"></a>Dubbo 可扩展机制实战</h1><h2 id="Dubbo的扩展机制"><a href="#Dubbo的扩展机制" class="headerlink" title="Dubbo的扩展机制"></a>Dubbo的扩展机制</h2><p>在 <code>Dubbo</code> 的官网上，<code>Dubbo</code> 描述自己是一个高性能的 <code>RPC</code> 框架。今天我想聊聊 <code>Dubbo</code> 的另一个很棒的特性，就是它的可扩展性。 如同罗马不是一天建成的，任何系统都一定是从小系统不断发展成为大系统的，想要从一开始就把系统设计的足够完善是不可能的；相反的，我们应该关注当下的需求，然后再不断地对系统进行迭代。在代码层面，要求我们适当的对关注点进行抽象和隔离，在软件不断添加功能和特性时，依然能保持良好的结构和可维护性，同时允许第三方开发者对其功能进行扩展。在某些时候，软件设计者对扩展性的追求甚至超过了性能。</p><p>在谈到软件设计时，可扩展性一直被谈起，那到底什么才是可扩展性，什么样的框架才算有良好的可扩展性呢？它必须要做到以下两点：</p><ul><li><p>作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则；</p></li><li><p>作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码即可。</p></li></ul><p><code>Dubbo</code> 很好的做到了上面两点。这要得益于 <code>Dubbo</code> 的 <strong>微内核</strong> + <strong>插件</strong> 的机制。接下来的章节中我们会慢慢揭开 <code>Dubbo</code> 扩展机制的神秘面纱。</p><h2 id="可扩展的几种解决方案"><a href="#可扩展的几种解决方案" class="headerlink" title="可扩展的几种解决方案"></a>可扩展的几种解决方案</h2><p>通常可扩展的实现有下面几种：</p><ul><li><p>Factory 模式</p></li><li><p>IOC 容器</p></li><li><p>OSGI 容器</p></li></ul><p><code>Dubbo</code> 作为一个框架，不希望强依赖其他的 <code>IOC</code> 容器，比如 <code>Spring</code>、<code>Guice</code>。<code>OSGI</code> 也是一个很重的实现，不适合 <code>Dubbo</code>。最终 <code>Dubbo</code> 的实现参考了 <code>Java</code> 原生的 <code>SPI</code> 机制，但对其进行了一些扩展，以满足 <code>Dubbo</code> 的需求。</p><h2 id="Dubbo-的-SPI-机制"><a href="#Dubbo-的-SPI-机制" class="headerlink" title="Dubbo 的 SPI 机制"></a>Dubbo 的 SPI 机制</h2><p><code>Java</code> <code>SPI</code> 的使用很简单。也做到了基本的加载扩展点的功能。但 <code>Java</code> <code>SPI</code> 有以下的不足：</p><ul><li><p>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现；</p></li><li><p>配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名，导致在程序中很难去准确的引用它们；</p></li><li><p>扩展如果依赖其他的扩展，做不到自动注入和装配；</p></li><li><p>不提供类似于 <code>Spring</code> 的 <code>IOC</code> 和 <code>AOP</code> 功能；</p></li><li><p>扩展很难和其他的框架集成，比如扩展里面依赖了一个 <code>Spring</code> <code>bean</code>，原生的 <code>Java</code> <code>SPI</code> 不支持。</p></li></ul><p>所以 <code>Java</code> <code>SPI</code> 应付一些简单的场景是可以的，但对于 <code>Dubbo</code>，它的功能还是比较弱的。<code>Dubbo</code> 对原生 <code>SPI</code> 机制进行了一些扩展，接下来，我们就更深入地了解下 <code>Dubbo</code> 的 <code>SPI</code> 机制。</p><h2 id="Dubbo-扩展点机制基本概念"><a href="#Dubbo-扩展点机制基本概念" class="headerlink" title="Dubbo 扩展点机制基本概念"></a>Dubbo 扩展点机制基本概念</h2><p>在深入学习 <code>Dubbo</code> 的扩展机制之前，我们先明确 <code>Dubbo</code> <code>SPI</code> 中的一些基本概念，在接下来的内容中，我们会多次用到这些术语。</p><h3 id="扩展点-Extension-Point"><a href="#扩展点-Extension-Point" class="headerlink" title="扩展点 (Extension Point)"></a>扩展点 (Extension Point)</h3><p>是一个 <code>Java</code> 的接口。</p><h3 id="扩展-Extension"><a href="#扩展-Extension" class="headerlink" title="扩展 (Extension)"></a>扩展 (Extension)</h3><p>扩展点的实现类。</p><h3 id="扩展实例-Extension-Instance"><a href="#扩展实例-Extension-Instance" class="headerlink" title="扩展实例 (Extension Instance)"></a>扩展实例 (Extension Instance)</h3><p>扩展点实现类的实例。</p><h3 id="扩展自适应实例-Extension-Adaptive-Instance"><a href="#扩展自适应实例-Extension-Adaptive-Instance" class="headerlink" title="扩展自适应实例 (Extension Adaptive Instance)"></a>扩展自适应实例 (Extension Adaptive Instance)</h3><p>第一次接触这个概念时，可能不太好理解（我第一次也是这样的…）。如果称它为扩展代理类，可能更好理解些。扩展的自适应实例其实就是一个 <code>Extension</code> 的代理，它实现了扩展点接口。在调用扩展点的接口方法时，会根据实际的参数来决定要使用哪个扩展。比如一个 <code>IRepository</code> 的扩展点，有一个 <code>save</code> 方法。有两个实现 <code>MysqlRepository</code> 和 <code>MongoRepository</code>。<code>IRepository</code> 的自适应实例在调用接口方法的时候，会根据 <code>save</code> 方法中的参数，来决定要调用哪个 <code>IRepository</code> 的实现。如果方法参数中有 <code>repository=mysql</code>，那么就调用 <code>MysqlRepository</code> 的 <code>save</code> 方法。如果 <code>repository=mongo</code>，就调用 <code>MongoRepository</code> 的 <code>save</code> 方法。和面向对象的延迟绑定很类似。为什么 <code>Dubbo</code> 会引入扩展自适应实例的概念呢？</p><ul><li><p><code>Dubbo</code> 中的配置有两种，一种是固定的系统级别的配置，在 <code>Dubbo</code> 启动之后就不会再改了。还有一种是运行时的配置，可能对于每一次的 <code>RPC</code>，这些配置都不同。比如在 <code>XML</code> 文件中配置了超时时间是 <code>10</code> 秒钟，这个配置在 <code>Dubbo</code> 启动之后，就不会改变了。但针对某一次的 <code>RPC</code> 调用，可以设置它的超时时间是 <code>30</code> 秒钟，以覆盖系统级别的配置。对于 <code>Dubbo</code> 而言，每一次的 <code>RPC</code> 调用的参数都是未知的。只有在运行时，根据这些参数才能做出正确的决定。</p></li><li><p>很多时候，我们的类都是一个单例的，比如 <code>Spring</code> 的 <code>bean</code>，在 <code>Spring</code> <code>bean</code> 都实例化时，如果它依赖某个扩展点，但是在 <code>bean</code> 实例化时，是不知道究竟该使用哪个具体的扩展实现的。这时候就需要一个代理模式了，它实现了扩展点接口，方法内部可以根据运行时参数，动态的选择合适的扩展实现。而这个代理就是自适应实例。自适应扩展实例在 <code>Dubbo</code> 中的使用非常广泛，<code>Dubbo</code> 中，每一个扩展都会有一个自适应类，如果我们没有提供，<code>Dubbo</code> 会使用字节码工具为我们自动生成一个。所以我们基本感觉不到自适应类的存在。后面会有例子说明自适应类是怎么工作的。</p></li></ul><h3 id="SPI"><a href="#SPI" class="headerlink" title="@SPI"></a>@SPI</h3><p><code>@SPI</code> 注解作用于扩展点的接口上，表明该接口是一个扩展点。可以被 <code>Dubbo</code> 的 <code>ExtentionLoader</code> 加载。如果没有此注解 <code>ExtensionLoader</code> 调用会异常。</p><h3 id="Adaptive"><a href="#Adaptive" class="headerlink" title="@Adaptive"></a>@Adaptive</h3><p><code>@Adaptive</code> 注解用在扩展接口的方法上。表示该方法是一个自适应方法。<code>Dubbo</code> 在为扩展点生成自适应实例时，如果方法有 <code>@Adaptive</code> 注解，会为该方法生成对应的代码。方法内部会根据方法的参数，来决定使用哪个扩展。 <code>@Adaptive</code> 注解用在类上代表实现一个装饰类，类似于设计模式中的装饰模式，它主要作用是返回指定类，目前在整个系统中 <code>AdaptiveCompiler</code>、 <code>AdaptiveExtensionFactory</code> 这两个类拥有该注解。</p><h3 id="ExtentionLoader"><a href="#ExtentionLoader" class="headerlink" title="ExtentionLoader"></a>ExtentionLoader</h3><p>类似于 <code>Java</code> <code>SPI</code> 的 <code>ServiceLoader</code>，负责扩展的加载和生命周期维护。</p><h3 id="扩展别名"><a href="#扩展别名" class="headerlink" title="扩展别名"></a>扩展别名</h3><p>和 <code>Java</code> <code>SPI</code> 不同，<code>Dubbo</code> 中的扩展都有一个别名，用于在应用中引用它们。比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</span><br><span class="line">roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</span><br></pre></td></tr></table></figure><p>其中的 <code>random</code>，<code>roundrobin</code> 就是对应扩展的别名。这样我们在配置文件中使用 <code>random</code> 或 <code>roundrobin</code> 就可以了。</p><h3 id="一些路径"><a href="#一些路径" class="headerlink" title="一些路径"></a>一些路径</h3><p>和 <code>Java</code> <code>SPI</code> 从 <code>/META-INF/services</code> 目录加载扩展配置类似，<code>Dubbo</code> 也会从以下路径去加载扩展配置文件：</p><ul><li><p>META-INF/dubbo/internal</p></li><li><p>META-INF/dubbo</p></li><li><p>META-INF/services</p></li></ul><h2 id="Dubbo-的-LoadBalance-扩展点解读"><a href="#Dubbo-的-LoadBalance-扩展点解读" class="headerlink" title="Dubbo 的 LoadBalance 扩展点解读"></a>Dubbo 的 LoadBalance 扩展点解读</h2><p>在了解了 <code>Dubbo</code> 的一些基本概念后，让我们一起来看一个 <code>Dubbo</code> 中实际的扩展点，对这些概念有一个更直观的认识。</p><p>我们选择的是 <code>Dubbo</code> 中的 <code>LoadBalance</code> 扩展点。<code>Dubbo</code> 中的一个服务，通常有多个 <code>Provider</code>，<code>consumer</code> 调用服务时，需要在多个 <code>Provider</code> 中选择一个，这就是一个 <code>LoadBalance</code>。我们一起来看看在 <code>Dubbo</code> 中，<code>LoadBalance</code> 是如何成为一个扩展点的。</p><h3 id="LoadBalance-接口"><a href="#LoadBalance-接口" class="headerlink" title="LoadBalance 接口"></a>LoadBalance 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(RandomLoadBalance.NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive(&quot;loadbalance&quot;)</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LoadBalance</code> 接口只有一个 <code>select</code> 方法。<code>select</code> 方法从多个 <code>invoker</code> 中选择其中一个。上面代码中和 <code>Dubbo</code> <code>SPI</code> 相关的元素有：</p><ul><li><code>@SPI(RandomLoadBalance.NAME)</code>：<code>@SPI</code> 作用于 <code>LoadBalance</code> 接口，表示接口 <code>LoadBalance</code> 是一个扩展点。如果没有 <code>@SPI</code> 注解，试图去加载扩展时，会抛出异常。<code>@SPI</code> 注解有一个参数，该参数表示该扩展点的默认实现的别名。如果没有显示的指定扩展，就使用默认实现。<code>RandomLoadBalance.NAME</code> 是一个常量，值是 <code>random</code>，是一个随机负载均衡的实现。 <code>random</code> 的定义在配置文件 <code>META-INF/dubbo/internal/com.alibaba.dubbo.rpc.cluster.LoadBalance</code> 中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</span><br><span class="line">roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</span><br><span class="line">leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance</span><br><span class="line">consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</span><br></pre></td></tr></table></figure><p>可以看到文件中定义了 <code>4</code> 个 <code>LoadBalance</code> 的扩展实现。由于负载均衡的实现不是本次的内容，这里就不过多说明。只用知道 <code>Dubbo</code> 提供了 <code>4</code> 种负载均衡的实现，我们可以通过 <code>XML</code> 文件，<code>properties</code> 文件，<code>JVM</code> 参数显式的指定一个实现。如果没有，默认使用随机。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2021/05-Java-SPI-In-Dubbo/dubbo-loadbalance.png" style="width:800px"><ul><li><code>@Adaptive(“loadbalance”)</code>：<code>@Adaptive</code> 注解修饰 <code>select</code> 方法，表明方法 <code>select</code> 方法是一个可自适应的方法。<code>Dubbo</code> 会自动生成该方法对应的代码，当调用 <code>select</code> 方法时，会根据具体的方法参数来决定调用哪个扩展实现的 <code>select</code> 方法。<code>@Adaptive</code> 注解的参数 <code>loadbalance</code> 表示方法参数中的 <code>loadbalance</code> 的值作为实际要调用的扩展实例。 但奇怪的是，我们发现 <code>select</code> 的方法中并没有 <code>loadbalance</code> 参数，那怎么获取 <code>loadbalance</code> 的值呢？<code>select</code> 方法中还有一个 <code>URL</code> 类型的参数，<code>Dubbo</code> 就是从 <code>URL</code> 中获取 <code>loadbalance</code> 的值的。这里涉及到 <code>Dubbo</code> 的 <code>URL</code> 总线模式，简单说，<code>URL</code> 中包含了 <code>RPC</code> 调用中的所有参数。<code>URL</code> 类中有一个 <code>Map&lt;String, String&gt; parameters</code> 字段，<code>parameters</code> 中就包含了 <code>loadbalance</code>。</li></ul><h3 id="获取-LoadBalance-扩展"><a href="#获取-LoadBalance-扩展" class="headerlink" title="获取 LoadBalance 扩展"></a>获取 LoadBalance 扩展</h3><p><code>Dubbo</code> 中获取 <code>LoadBalance</code> 的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName);</span><br></pre></td></tr></table></figure><p>使用 <code>ExtensionLoader.getExtensionLoader(LoadBalance.class)</code> 方法获取一个 <code>ExtensionLoader</code> 的实例，然后调用 <code>getExtension</code>，传入一个扩展的别名来获取对应的扩展实例。</p><h2 id="自定义一个-LoadBalance-扩展"><a href="#自定义一个-LoadBalance-扩展" class="headerlink" title="自定义一个 LoadBalance 扩展"></a>自定义一个 LoadBalance 扩展</h2><p>本节中，我们通过一个简单的例子，来自己实现一个 <code>LoadBalance</code>，并把它集成到 <code>Dubbo</code> 中。我会列出一些关键的步骤和代码，也可以从这个<a target="_blank" rel="noopener" href="https://github.com/vangoleo/dubbo-spi-demo">地址</a> 下载完整的 <code>demo</code>。</p><h3 id="实现-LoadBalance-接口"><a href="#实现-LoadBalance-接口" class="headerlink" title="实现 LoadBalance 接口"></a>实现 LoadBalance 接口</h3><p>首先，编写一个自己实现的 <code>LoadBalance</code>，因为是为了演示 <code>Dubbo</code> 的扩展机制，而不是 <code>LoadBalance</code> 的实现，所以这里 <code>LoadBalance</code> 的实现非常简单，选择第一个 <code>invoker</code>，并在控制台输出一条日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dubbo.spi.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DemoLoadBalance: Select the first invoker...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加扩展配置文件"><a href="#添加扩展配置文件" class="headerlink" title="添加扩展配置文件"></a>添加扩展配置文件</h3><p>添加文件：<code>META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</code>。文件内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo=com.dubbo.spi.demo.consumer.DemoLoadBalance</span><br></pre></td></tr></table></figure><h3 id="配置使用自定义-LoadBalance"><a href="#配置使用自定义-LoadBalance" class="headerlink" title="配置使用自定义 LoadBalance"></a>配置使用自定义 LoadBalance</h3><p>通过上面的两步，已经添加了一个名字为 <code>demo</code> 的 <code>LoadBalance</code> 实现，并在配置文件中进行了相应的配置。接下来，需要显式的告诉 <code>Dubbo</code> 使用 <code>demo</code> 的负载均衡实现。如果是通过 <code>Spring</code> 的方式使用 <code>Dubbo</code>，可以在xml文件中进行设置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.dubbo.spi.demo.api.IHelloService&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;demo&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>consumer</code> 端的 <code>dubbo:reference</code> 中配置 <code>&lt;loadbalance=“demo”&gt;</code></p><h3 id="启动-Dubbo"><a href="#启动-Dubbo" class="headerlink" title="启动 Dubbo"></a>启动 Dubbo</h3><p>启动 <code>Dubbo</code>，调用一次 <code>IHelloService</code>，可以看到控制台会输出一条</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DemoLoadBalance: Select the first invoker...</span><br></pre></td></tr></table></figure><p>日志，说明 <code>Dubbo</code> 的确是使用了我们自定义的 <code>LoadBalance</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，我们从 <code>Java</code> <code>SPI</code> 开始，了解了 <code>Dubbo</code> <code>SPI</code> 的基本概念，并结合了 <code>Dubbo</code> 中的 <code>LoadBalance</code> 加深了理解。最后，我们还实践了一下，创建了一个自定义 <code>LoadBalance</code>，并集成到 <code>Dubbo</code> 中。相信通过这里理论和实践的结合，大家对 <code>Dubbo</code> 的可扩展有更深入的理解。 总结一下，<code>Dubbo</code> <code>SPI</code> 有以下的特点：</p><ul><li><p>对 <code>Dubbo</code> 进行扩展，不需要改动 <code>Dubbo</code> 的源码；</p></li><li><p>自定义的 <code>Dubbo</code> 的扩展点实现，是一个普通的 <code>Java</code> 类，<code>Dubbo</code> 没有引入任何 <code>Dubbo</code> 特有的元素，对代码侵入性几乎为零；</p></li><li><p>将扩展注册到 <code>Dubbo</code> 中，只需要在 <code>ClassPath</code> 中添加配置文件，使用简单，而且不会对现有代码造成影响，符合开闭原则；</p></li><li><p><code>Dubbo</code> 的扩展机制设计默认值：<code>@SPI(“dubbo”)</code> 代表默认的 <code>SPI</code> 对象；</p></li><li><p><code>Dubbo</code> 的扩展机制支持 <code>IOC</code>、<code>AOP</code> 等高级功能；</p></li><li><p><code>Dubbo</code>的扩展机制能很好的支持第三方 <code>IOC</code> 容器，默认支持 <code>Spring</code> <code>Bean</code>，可自己扩展来支持其他容器，比如 <code>Google</code> 的 <code>Guice</code>；</p></li><li><p>切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码，使用方便。</p></li></ul><h1 id="Dubbo-可扩展机制源码解析"><a href="#Dubbo-可扩展机制源码解析" class="headerlink" title="Dubbo 可扩展机制源码解析"></a>Dubbo 可扩展机制源码解析</h1><h2 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h2><p><code>ExtensionLoader</code> 是最核心的类，负责扩展点的加载和生命周期管理，我们就以这个类开始吧。 <code>ExtensionLoader</code> 的方法比较多，比较常用的方法有：</p><ul><li><p><code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code></p></li><li><p><code>public T getExtension(String name)</code></p></li><li><p><code>public T getAdaptiveExtension()</code></p></li></ul><p>比较常见的用法有：</p><ul><li><p><code>LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName)</code></p></li><li><p><code>RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension()</code></p></li></ul><p>说明：在接下来展示的源码中，我会将无关的代码（比如日志，异常捕获等）去掉，方便大家阅读和理解。</p><ol><li><code>getExtensionLoader</code> 方法 这是一个静态工厂方法，入参是一个可扩展的接口，返回一个该接口的 <code>ExtensionLoader</code> 实体类。通过这个实体类，可以根据 <code>name</code> 获得具体的扩展，也可以获得一个自适应扩展。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="comment">// 扩展点必须是接口</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type(&quot;</span> + type + <span class="string">&quot;) is not interface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须要有@SPI注解</span></span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type without @SPI Annotation!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓存中根据接口获取对应的ExtensionLoader</span></span><br><span class="line">    <span class="comment">// 每个扩展只会被加载一次</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化扩展</span></span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="literal">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>getExtension</code> 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    <span class="comment">// 从缓存中获取，如果不存在就创建</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getExtension</code> 方法中做了一些判断和缓存，主要的逻辑在 <code>createExtension</code> 方法中，我们继续看 <code>createExtension</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据扩展点名称得到扩展类，比如对于LoadBalance，根据random得到RandomLoadBalance类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    </span><br><span class="line">    <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用反射调用nesInstance来创建扩展类的一个示例</span></span><br><span class="line">        EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());</span><br><span class="line">        instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对扩展类示例进行依赖注入</span></span><br><span class="line">    injectExtension(instance);</span><br><span class="line">    <span class="comment">// 如果有wrapper，添加wrapper</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">    <span class="keyword">if</span> (wrapperClasses != <span class="literal">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">            instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createExtension</code> 方法做了以下事情：</p><ul><li><p>先根据 <code>name</code> 来得到对应的扩展类，从 <code>ClassPath</code> 下 <code>META-INF</code> 文件夹下读取扩展点配置文件；</p></li><li><p>使用反射创建一个扩展类的实例；</p></li><li><p>对扩展类实例的属性进行依赖注入，即 <code>IOC</code>；</p></li><li><p>如果有 <code>wrapper</code>，添加 <code>wrapper</code>，即 <code>AOP</code>。</p></li></ul><p>下面我们来重点看下这 <code>4</code> 个过程</p><ol><li>根据 <code>name</code> 获取对应的扩展类 先看代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized in getExtensionClasses</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SPI</span> <span class="variable">defaultAnnotation</span> <span class="operator">=</span> type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> defaultAnnotation.value();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; (value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;more than 1 default extension name on extension &quot;</span> + type.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadFile(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadFile(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程很简单，先从缓存中获取，如果没有，就从配置文件中加载。配置文件的路径就是之前提到的：</p><ul><li><p><code>META-INF/dubbo/internal</code></p></li><li><p><code>META-INF/dubbo</code></p></li><li><p><code>META-INF/services</code></p></li></ul><ol start="2"><li><p>使用反射创建扩展实例：这个过程很简单，使用 <code>clazz.newInstance()</code> 来完成。创建的扩展实例的属性都是空值。</p></li><li><p>扩展实例自动装配：在实际的场景中，类之间都是有依赖的。扩展实例中也会引用一些依赖，比如简单的 <code>Java</code> 类，另一个 <code>Dubbo</code> 的扩展或一个 <code>Spring</code> <code>Bean</code> 等。依赖的情况很复杂，<code>Dubbo</code> 的处理也相对复杂些。我们稍后会有专门的章节对其进行说明，现在，我们只需要知道，<code>Dubbo</code> 可以正确的注入扩展点中的普通依赖，<code>Dubbo</code> 扩展依赖或 <code>Spring</code> 依赖等。</p></li><li><p>扩展实例自动包装：自动包装就是要实现类似于 <code>Spring</code> 的 <code>AOP</code> 功能。<code>Dubbo</code> 利用它在内部实现一些通用的功能，比如日志，监控等。关于扩展实例自动包装的内容，也会在后面单独讲解。</p></li></ol><p>经过上面的 <code>4</code> 步，<code>Dubbo</code> 就创建并初始化了一个扩展实例。这个实例的依赖被注入了，也根据需要被包装了。到此为止，这个扩展实例就可以被使用了。</p><h2 id="Dubbo-SPI-高级用法之自动装配"><a href="#Dubbo-SPI-高级用法之自动装配" class="headerlink" title="Dubbo SPI 高级用法之自动装配"></a>Dubbo SPI 高级用法之自动装配</h2><p>自动装配的相关代码在 <code>injectExtension</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">&quot;set&quot;</span>)</span><br><span class="line">                &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">          </span><br><span class="line">            <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">            <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                method.invoke(instance, object);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现对扩展实例的依赖的自动装配，首先需要知道有哪些依赖，这些依赖的类型是什么。<code>Dubbo</code> 的方案是查找 <code>Java</code> 标准的 <code>setter</code> 方法。即方法名以 <code>set</code> 开始，只有一个参数。如果扩展类中有这样的 <code>set</code> 方法，<code>Dubbo</code> 会对其进行依赖注入，类似于 <code>Spring</code> 的 <code>set</code> 方法注入。 但是 <code>Dubbo</code> 中的依赖注入比 <code>Spring</code> 要复杂，因为 <code>Spring</code> 注入的都是 <code>Spring</code> <code>bean</code>，都是由 <code>Spring</code> 容器来管理的。而 <code>Dubbo</code> 的依赖注入中，需要注入的可能是另一个 <code>Dubbo</code> 的扩展，也可能是一个 <code>Spring</code> <code>Bean</code>，或是 <code>Google</code> <code>guice</code> 的组件，或其他任何一个框架中的组件。<code>Dubbo</code> 需要能够从任何一个场景中加载扩展。在 <code>injectExtension</code> 方法中，是用 <code>Object object = objectFactory.getExtension(pt, property)</code> 来实现的。<code>objectFactory</code> 是 <code>ExtensionFactory</code> 类型的，在创建 <code>ExtensionLoader</code> 时被初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="literal">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objectFacory</code> 本身也是一个扩展，通过 <code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())</code> 来获取。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2021/05-Java-SPI-In-Dubbo/dubbo-extensionfactory.png" style="width:800px"><p><code>ExtensionFactory</code> 有三个实现：</p><ol><li><p><code>SpiExtensionFactory</code>：<code>Dubbo</code> 自己的 <code>SPI</code> 去加载 <code>Extension</code>；</p></li><li><p><code>SpringExtensionFactory</code>：从 <code>Spring</code> 容器中去加载 <code>Extension</code>；</p></li><li><p><code>AdaptiveExtensionFactory</code>: 自适应的 <code>AdaptiveExtensionLoader</code>。</p></li></ol><p>这里要注意 <code>AdaptiveExtensionFactory</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title class_">ExtensionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdaptiveExtensionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ExtensionFactory&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">extension</span> <span class="operator">=</span> factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AdaptiveExtensionLoader</code> 类有 <code>@Adaptive</code> 注解。前面提到了，<code>Dubbo</code> 会为每一个扩展创建一个自适应实例。如果扩展类上有 <code>@Adaptive</code>，会使用该类作为自适应类。如果没有，<code>Dubbo</code> 会为我们创建一个。所以 <code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())</code> 会返回一个 <code>AdaptiveExtensionLoader</code> 实例，作为自适应扩展实例。 <code>AdaptiveExtensionLoader</code> 会遍历所有的 <code>ExtensionFactory</code> 实现，尝试着去加载扩展。如果找到了，返回。如果没有，在下一个 <code>ExtensionFactory</code> 中继续找。<code>Dubbo</code> 内置了两个 <code>ExtensionFactory</code>，分别从 <code>Dubbo</code> 自身的扩展机制和 <code>Spring</code> 容器中去寻找。由于 <code>ExtensionFactory</code> 本身也是一个扩展点，我们可以实现自己的 <code>ExtensionFactory</code>，让 <code>Dubbo</code> 的自动装配支持我们自定义的组件。比如，我们在项目中使用了 <code>Google</code> 的 <code>guice</code> 这个 <code>IOC</code> 容器。我们可以实现自己的 <code>GuiceExtensionFactory</code>，让 <code>Dubbo</code> 支持从 <code>guice</code> 容器中加载扩展。</p><h2 id="Dubbo-SPI-高级用法之-AOP"><a href="#Dubbo-SPI-高级用法之-AOP" class="headerlink" title="Dubbo SPI 高级用法之 AOP"></a>Dubbo SPI 高级用法之 AOP</h2><p>在用 <code>Spring</code> 的时候，我们经常会用到 <code>AOP</code> 功能。在目标类的方法前后插入其他逻辑。比如通常使用 <code>Spring</code> <code>AOP</code> 来实现日志，监控和鉴权等功能。 <code>Dubbo</code> 的扩展机制，是否也支持类似的功能呢？答案是 <code>yes</code>。在 <code>Dubbo</code> 中，有一种特殊的类，被称为 <code>Wrapper</code> 类。通过装饰者模式，使用包装类包装原始的扩展点实例。在原始扩展点实现前后插入其他逻辑，实现 <code>AOP</code> 功能。</p><h3 id="什么是-Wrapper-类"><a href="#什么是-Wrapper-类" class="headerlink" title="什么是 Wrapper 类"></a>什么是 Wrapper 类</h3><p>那什么样类的才是 <code>Dubbo</code> 扩展机制中的 <code>Wrapper</code> 类呢？<code>Wrapper</code> 类是一个有复制构造函数的类，也是典型的装饰者模式。下面就是一个 <code>Wrapper</code> 类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <code>A</code> 有一个构造函数 <code>public A(A a)</code>，构造函数的参数是 <code>A</code> 本身。这样的类就可以成为 <code>Dubbo</code> 扩展机制中的一个 <code>Wrapper</code> 类。<code>Dubbo</code> 中这样的 <code>Wrapper</code> 类有 <code>ProtocolFilterWrapper</code>, <code>ProtocolListenerWrapper</code> 等, 大家可以查看源码加深理解。</p><h3 id="怎么配置-Wrapper-类"><a href="#怎么配置-Wrapper-类" class="headerlink" title="怎么配置 Wrapper 类"></a>怎么配置 Wrapper 类</h3><p>在 <code>Dubbo</code> 中 <code>Wrapper</code> 类也是一个扩展点，和其他的扩展点一样，也是在 <code>META-INF</code> 文件夹中配置的。比如前面举例的 <code>ProtocolFilterWrapper</code> 和 <code>ProtocolListenerWrapper</code> 就是在路径 <code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol</code> 中配置的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line">mock=org.apache.dubbo.rpc.support.MockProtocol</span><br></pre></td></tr></table></figure><p>在 <code>Dubbo</code> 加载扩展配置文件时，有一段如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    clazz.getConstructor(type);    </span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">    <span class="keyword">if</span> (wrappers == <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedWrapperClasses = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        wrappers = cachedWrapperClasses;</span><br><span class="line">    &#125;</span><br><span class="line">    wrappers.add(clazz);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是，如果扩展类有复制构造函数，就把该类存起来，供以后使用。有复制构造函数的类就是 <code>Wrapper</code> 类。通过 <code>clazz.getConstructor(type)</code> 来获取参数是扩展点接口的构造函数。注意构造函数的参数类型是扩展点接口，而不是扩展类。 以 <code>Protocol</code> 为例。配置文件 <code>dubbo-rpc/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol</code> 中定义了 <code>filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</code>。 <code>ProtocolFilterWrapper</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个参数是Protocol的复制构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;protocol == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProtocolFilterWrapper</code> 有一个构造函数 <code>public ProtocolFilterWrapper(Protocol protocol)</code>，参数是扩展点 <code>Protocol</code>，所以它是一个 <code>Dubbo</code> 扩展机制中的 <code>Wrapper</code> 类。<code>ExtensionLoader</code> 会把它缓存起来，供以后创建 <code>Extension</code> 实例的时候，使用这些包装类依次包装原始扩展点。</p><h2 id="扩展点自适应"><a href="#扩展点自适应" class="headerlink" title="扩展点自适应"></a>扩展点自适应</h2><p>前面讲到过，<code>Dubbo</code> 需要在运行时根据方法参数来决定该使用哪个扩展，所以有了扩展点自适应实例。其实是一个扩展点的代理，将扩展的选择从 <code>Dubbo</code> 启动时，延迟到 <code>RPC</code> 调用时。<code>Dubbo</code> 中每一个扩展点都有一个自适应类，如果没有显式提供，<code>Dubbo</code> 会自动为我们创建一个，默认使用 <code>Javaassist</code>。 先来看下创建自适应扩展类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                      instance = createAdaptiveExtension();</span><br><span class="line">                      cachedAdaptiveInstance.set(instance); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>createAdaptiveExtension</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;        </span><br><span class="line">    <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>getAdaptiveExtensionClass</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>createAdaptiveExtensionClass</code> 方法，绕了一大圈，终于来到了具体的实现了。看这个 <code>createAdaptiveExtensionClass</code> 方法，它首先会生成自适应类的 <code>Java</code> 源码，然后再将源码编译成 <code>Java</code> 的字节码，加载到 <code>JVM</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> createAdaptiveExtensionClassCode();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">    org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Compiler</code> 的代码，默认实现是 <code>javassist</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">    Class&lt;?&gt; compile(String code, ClassLoader classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createAdaptiveExtensionClassCode()</code> 方法中使用一个 <code>StringBuilder</code> 来构建自适应类的 <code>Java</code> 源码。方法实现比较长，这里就不贴代码了。这种生成字节码的方式也挺有意思的，先生成 <code>Java</code> 源代码，然后编译，加载到 <code>JVM</code> 中。通过这种方式，可以更好的控制生成的 <code>Java</code> 类。而且这样也不用 <code>care</code> 各个字节码生成框架的 <code>api</code> 等。因为 <code>xxx.java</code> 文件是 <code>Java</code> 通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建 <code>xx.java</code> 的内容。 下面是使用 <code>createAdaptiveExtensionClassCode</code> 方法为 <code>Protocol</code> 创建的自适应类的Java代码范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">org</span>.apache.dubbo.rpc.Protocol &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Exporter <span class="title function_">export</span><span class="params">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0.getUrl() == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg0.getUrl();</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> (url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.rpc.Invoker <span class="title function_">refer</span><span class="params">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class="keyword">throws</span> org.apache.dubbo.rpc.RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg1 == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> arg1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">extName</span> <span class="operator">=</span> (url.getProtocol() == <span class="literal">null</span> ? <span class="string">&quot;dubbo&quot;</span> : url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([protocol])&quot;</span>);</span><br><span class="line">        org.apache.dubbo.rpc.<span class="type">Protocol</span> <span class="variable">extension</span> <span class="operator">=</span> (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的逻辑和开始说的一样，通过 <code>url</code> 解析出参数，解析的逻辑由 <code>@Adaptive</code> 的 <code>value</code> 参数控制，然后再根据得到的扩展点名获取扩展点实现，然后进行调用。如果大家想知道具体的构建 <code>.java</code> 代码的逻辑，可以看 <code>createAdaptiveExtensionClassCode</code> 的完整实现。 在生成的 <code>Protocol$Adaptive</code> 中，发现 <code>getDefaultPort</code> 和 <code>destroy</code> 方法都是直接抛出异常的，这是为什么呢？来看看 <code>Protocol</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getDefaultPort</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Protocol</code> 接口中有 <code>4</code> 个方法，但只有 <code>export</code> 和 <code>refer</code> 两个方法使用了 <code>@Adaptive</code> 注解。<code>Dubbo</code> 自动生成的自适应实例，只有 <code>@Adaptive</code> 修饰的方法才有具体的实现。所以，<code>Protocol$Adaptive</code> 类中，也只有 <code>export</code> 和 <code>refer</code> 这两个方法有具体的实现，其余方法都是抛出异常。</p><div class="post-announce">感谢您的阅读，本文由 <a href="https://dongzl.github.io">董宗磊的博客</a> 版权所有。如若转载，请注明出处：董宗磊的博客（<a href="https://dongzl.github.io/2021/01/23/05-Java-SPI-In-Dubbo/">https://dongzl.github.io/2021/01/23/05-Java-SPI-In-Dubbo/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2021/01/16/04-Java-Service-Provider-Interface/" title="Java SPI 使用及原理分析"><i class="iconfont icon-prev"></i>Java SPI 使用及原理分析</a></div><div class="post__prev post__prev--right"><a href="/2021/01/27/06-Ping-Fan-De-Shi-Jie/" title="《平凡的世界》经典语录摘抄">《平凡的世界》经典语录摘抄<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">记录自己作为程序员的技术成长经历，程序员是个特殊的职业，一旦选择这个职业就要时刻保持学习的热情，如果你也喜欢我的博客，欢迎订阅 RSS。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="block-list-count">5</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">架构设计</a><span class="block-list-count">29</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="block-list-count">25</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/web%E5%BC%80%E5%8F%91/">web开发</a><span class="block-list-count">11</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/java%E5%BC%80%E5%8F%91/">java开发</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Go%E8%AF%AD%E8%A8%80/">Go语言</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2023/12/19/26-Asynchronous-API-Design-Best-Practices-Server-Sent-Event/" title="异步 API 设计最佳实践：用于实时通信的服务端事件发送 (SSE)"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/async_vs_sync.png" alt="异步 API 设计最佳实践：用于实时通信的服务端事件发送 (SSE)"></div><div class="item__info"><h3 class="item__title">异步 API 设计最佳实践：用于实时通信的服务端事件发送 (SSE)</h3><span class="item__text">2023-12-19</span></div></a></li><li class="latest-post-item"><a href="/2023/11/18/25-Difference-Between-Forward-Proxy-Reverse-Proxy-System-Design/" title="系统设计中正向代理和反向代理的差异"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/forward_reverse_proxy_v2.png" alt="系统设计中正向代理和反向代理的差异"></div><div class="item__info"><h3 class="item__title">系统设计中正向代理和反向代理的差异</h3><span class="item__text">2023-11-18</span></div></a></li><li class="latest-post-item"><a href="/2023/09/23/24-Scaling-Microservices-Strategies-Handling-Increased-Demand-Efficiency/" title="微服务扩展：以 99% 的处理效率来应对不断增长的需求"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/scaling_microservices.png" alt="微服务扩展：以 99% 的处理效率来应对不断增长的需求"></div><div class="item__info"><h3 class="item__title">微服务扩展：以 99% 的处理效率来应对不断增长的需求</h3><span class="item__text">2023-09-23</span></div></a></li><li class="latest-post-item"><a href="/2023/08/27/23-Difference-Between-SAGA-CQRS-Design-Patterns-Microservices/" title="微服务中 SAGA 和 CQRS 设计模式的差异？"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/SAGA_vs_CQRS.png" alt="微服务中 SAGA 和 CQRS 设计模式的差异？"></div><div class="item__info"><h3 class="item__title">微服务中 SAGA 和 CQRS 设计模式的差异？</h3><span class="item__text">2023-08-27</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/AQS/">AQS</a></li><li class="tag-item"><a class="tag-link" href="/tags/ActiveMQ/">ActiveMQ</a></li><li class="tag-item"><a class="tag-link" href="/tags/Apache/">Apache</a></li><li class="tag-item"><a class="tag-link" href="/tags/BloomFilter/">BloomFilter</a></li><li class="tag-item"><a class="tag-link" href="/tags/CQRS/">CQRS</a></li><li class="tag-item"><a class="tag-link" href="/tags/Calcite/">Calcite</a></li><li class="tag-item"><a class="tag-link" href="/tags/ClickHouse/">ClickHouse</a></li><li class="tag-item"><a class="tag-link" href="/tags/CountDownLatch/">CountDownLatch</a></li><li class="tag-item"><a class="tag-link" href="/tags/Docker/">Docker</a></li><li class="tag-item"><a class="tag-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-item"><a class="tag-link" href="/tags/Full-GC/">Full GC</a></li><li class="tag-item"><a class="tag-link" href="/tags/Go/">Go</a></li><li class="tag-item"><a class="tag-link" href="/tags/GraphQL/">GraphQL</a></li><li class="tag-item"><a class="tag-link" href="/tags/Guava/">Guava</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hibernate/">Hibernate</a></li><li class="tag-item"><a class="tag-link" href="/tags/Istio/">Istio</a></li><li class="tag-item"><a class="tag-link" href="/tags/JPA/">JPA</a></li><li class="tag-item"><a class="tag-link" href="/tags/JSON/">JSON</a></li><li class="tag-item"><a class="tag-link" href="/tags/JVM/">JVM</a></li><li class="tag-item"><a class="tag-link" href="/tags/JWT/">JWT</a></li><li class="tag-item"><a class="tag-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-item"><a class="tag-link" href="/tags/Linux/">Linux</a></li><li class="tag-item"><a class="tag-link" href="/tags/Lock/">Lock</a></li><li class="tag-item"><a class="tag-link" href="/tags/Lombok/">Lombok</a></li><li class="tag-item"><a class="tag-link" href="/tags/MAT/">MAT</a></li><li class="tag-item"><a class="tag-link" href="/tags/Map/">Map</a></li><li class="tag-item"><a class="tag-link" href="/tags/Microservices/">Microservices</a></li><li class="tag-item"><a class="tag-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-item"><a class="tag-link" href="/tags/OAuth/">OAuth</a></li><li class="tag-item"><a class="tag-link" href="/tags/Performance-Schema/">Performance Schema</a></li><li class="tag-item"><a class="tag-link" href="/tags/REST/">REST</a></li><li class="tag-item"><a class="tag-link" href="/tags/RSocket/">RSocket</a></li><li class="tag-item"><a class="tag-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-item"><a class="tag-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-item"><a class="tag-link" href="/tags/Redis/">Redis</a></li><li class="tag-item"><a class="tag-link" href="/tags/Rust/">Rust</a></li><li class="tag-item"><a class="tag-link" href="/tags/SAGA/">SAGA</a></li><li class="tag-item"><a class="tag-link" href="/tags/SAML/">SAML</a></li><li class="tag-item"><a class="tag-link" href="/tags/SPI/">SPI</a></li><li class="tag-item"><a class="tag-link" href="/tags/SSE/">SSE</a></li><li class="tag-item"><a class="tag-link" href="/tags/Security/">Security</a></li><li class="tag-item"><a class="tag-link" href="/tags/Service-Mesh/">Service Mesh</a></li><li class="tag-item"><a class="tag-link" href="/tags/ShardingSphere/">ShardingSphere</a></li><li class="tag-item"><a class="tag-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring/">Spring</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring-Data-JPA/">Spring Data JPA</a></li><li class="tag-item"><a class="tag-link" href="/tags/TestContainers/">TestContainers</a></li><li class="tag-item"><a class="tag-link" href="/tags/Thread/">Thread</a></li><li class="tag-item"><a class="tag-link" href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a></li><li class="tag-item"><a class="tag-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-item"><a class="tag-link" href="/tags/Zero-Copy/">Zero Copy</a></li><li class="tag-item"><a class="tag-link" href="/tags/ZooKeeper/">ZooKeeper</a></li><li class="tag-item"><a class="tag-link" href="/tags/eBPF/">eBPF</a></li><li class="tag-item"><a class="tag-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-item"><a class="tag-link" href="/tags/hexo/">hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/maven/">maven</a></li><li class="tag-item"><a class="tag-link" href="/tags/synchronized/">synchronized</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/">两阶段提交</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">主从复制</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90/">事件溯源</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%BA%8B%E5%8A%A1/">事务</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%BC%B9%E6%80%A7/">弹性</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%80%BB%E7%BB%93/">总结</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">数学公式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/">正向代理</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%B2%89%E6%80%9D%E5%BD%95/">沉思录</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%BD%91%E5%85%B3/">网关</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">设计原则</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B0%83%E4%BC%98/">调优</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>dongzonglei@apache.org</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/theme/qrcode.jpeg" alt="logo" title="董宗磊的博客"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://mrdear.cn/" title="mrdear" target="_blank">mrdear</a></li><li class="list-item"><a href="https://tech.meituan.com/" title="美团技术团队" target="_blank">美团技术团队</a></li><li class="list-item"><a href="https://coolshell.cn/" title="酷 壳–CoolShell" target="_blank">酷 壳–CoolShell</a></li><li class="list-item"><a href="https://tech.youzan.com/" title="有赞技术团队" target="_blank">有赞技术团队</a></li><li class="list-item"><a href="https://insights.thoughtworks.cn" title="Thoughtworks洞见" target="_blank">Thoughtworks洞见</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">大V博客</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://draveness.me/" title="draveness" target="_blank">draveness</a></li><li class="list-item"><a href="http://www.ruanyifeng.com/home.html" title="阮一峰的个人网站" target="_blank">阮一峰</a></li><li class="list-item"><a href="https://blog.devtang.com/" title="唐巧的博客" target="_blank">唐巧的博客</a></li><li class="list-item"><a href="https://www.hollischuang.com/" title="Hollis" target="_blank">Hollis</a></li><li class="list-item"><a href="http://coder5.cn/" title="武哥漫谈IT" target="_blank">武哥漫谈IT</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="hexo-theme-skapp" target="_blank">hexo-theme-skapp</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/dongzl" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:dongzonglei@apache.org" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["SPI"],gitalk=new Gitalk({clientID:"791785cb3bf7b9b5f1ea",clientSecret:"a73d2380b7dba08575e0190989ef017e480c20c9",repo:"dongzl.github.io",owner:"dongzl",admin:["dongzl"],labels:tags,id:new Date(1611424856e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/haruto.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0},react:{opacity:1},log:!1})</script></body></html>