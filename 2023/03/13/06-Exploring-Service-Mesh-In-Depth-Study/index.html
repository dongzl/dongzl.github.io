<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>深入探索 Service Mesh 技术：Istio、eBPF 和 RSocket Broker | 董宗磊的博客--靡不有初，鲜克有终</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="程序员, java, web, 数据库, 架构, 设计模式, 数据结构, 算法"><meta name="description" content="记录自己作为程序员的技术成长经历，程序员是个特殊的职业，一旦选择这个职业就要时刻保持学习的热情，如果你也喜欢我的博客，欢迎订阅 RSS。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://dongzl.github.io/2023/03/13/06-Exploring-Service-Mesh-In-Depth-Study/index.html"><link rel="icon" type="image/png" href="/img/theme/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="董宗磊的博客" type="application/atom+xml"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 7.0.0"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/theme/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="董宗磊的博客" alt="董宗磊的博客"><img src="/img/theme/title.png" alt="董宗磊的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a target="_blank" rel="noopener" href="https://course.rs/about-book.html" alt="Rust" title="Rust">Rust</a></li><li class="nav__item"><a href="https://dongzl.github.io/netty-handbook/" alt="Netty" title="Netty">Netty</a></li><li class="nav__item"><a href="/2019/01/01/01-Excellent-Article-Link/" alt="好文链接" title="好文链接">好文链接</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/service_mesh.png" alt="深入探索 Service Mesh 技术：Istio、eBPF 和 RSocket Broker"></div><header class="post__info"><h1 class="post__title">深入探索 Service Mesh 技术：Istio、eBPF 和 RSocket Broker</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a target="_blank" rel="noopener" href="https://medium.com/@deepkondah">Kondah Mouad</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2023-03-13</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Service-Mesh/">Service Mesh</a></li><li class="mark__item"><a href="/tags/Istio/">Istio</a></li><li class="mark__item"><a href="/tags/eBPF/">eBPF</a></li><li class="mark__item"><a href="/tags/RSocket/">RSocket</a></li></ul></div></div></header><div class="post__content"><blockquote><p>原文链接：<a target="_blank" rel="noopener" href="https://medium.com/geekculture/istio-ebpf-and-rsocket-broker-a-deep-dive-into-service-mesh-7ec4871d50bb">https://medium.com/geekculture/istio-ebpf-and-rsocket-broker-a-deep-dive-into-service-mesh-7ec4871d50bb</a></p></blockquote><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在微服务时代，单个复杂的应用程序被拆分成多个<strong>组件化</strong>、<strong>协作</strong>和<strong>连接</strong>的单元，单个服务往往会堆积越来越多的业务功能，这使得服务治理工作的困难前所未有，仅仅依靠微服务框架层面的治理是不够的，还需要构建高维度的深度治理体系。</p><p>本文将从多个角度审视服务治理内容，并通过对传统和现代方案进行探索，提供一些对 <code>Service Mesh</code>、<code>Istio</code>、<code>eBPF</code> 和 <code>RSocket Broker</code> 技术的理解。</p><h2 id="1-服务治理"><a href="#1-服务治理" class="headerlink" title="1. 服务治理"></a>1. 服务治理</h2><p>服务治理是指建立和实施一套流程，这套流程能够展示出微服务是如何通过协同工作来实现系统设计和构建的业务目标的。有一点很重要，就是服务不要超出其所负责的边界。</p><p>服务治理可以通过多种方式实现：</p><ul><li>服务注册和发现：<code>Consul</code>、<code>ZooKeeper</code>；</li><li>服务配置：<code>Spring Cloud Config</code>；</li><li>服务容错：<code>Hystrix</code>；</li><li>网关：<code>Zuul</code>、<code>Spring Cloud Gateway</code>；</li><li>负载均衡：<code>Ribbon</code>、<code>Feign</code>；</li><li>追踪工具：<code>Sleuth</code>、<code>Sleuth</code>、<code>Htrace</code>；</li><li>监控工具：<code>Grafana</code>、<code>Prometheus</code>。</li></ul><p>接下来，我们将讨论其中的一些内容。</p><h3 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h3><p>在云服务器架构时代，将单个大型单体应用程序拆分成更小的可独立部署的服务单元过程，称为微服务。</p><p>当某一个服务需要与其它服务进行通信时，它需要知道远端服务的<strong>IP地址</strong>和<strong>端口</strong>。一种直接的解决方案是维护一个配置文件记录目标服务的<strong>IP地址</strong>和<strong>端口</strong>，但是这种方式存在很多不足，其中之一就是不具备云服务的可扩展性，云服务为我们提供了根据当前负载弹性<strong>扩容/缩容</strong>服务器实例的能力，使用配置文件的方式根本没有办法使用这种能力。</p><p>这就是服务发现发挥作用的地方，它通过服务注册的机制来解决上述问题，也就是说，当一个新服务启动并想要参与处理客户端请求时，它会通过<strong>IP地址</strong>和<strong>端口</strong>将自己注册到注册中心，并且这些注册的信息可以被客户端获取到。此外，通过服务健康检查机制可以确保客户端请求流量只转发到健康的实例。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是一种请求调度策略，它可以协调多台服务器共同处理网络请求，从而扩展系统的处理能力。在后面的部分中，我们将尝试使用 <code>RSocket</code> 技术实现跨服务器资源池的智能负载均衡策略，来平衡客户端请求。</p><h2 id="2-Sidecar-模式"><a href="#2-Sidecar-模式" class="headerlink" title="2. Sidecar 模式"></a>2. Sidecar 模式</h2><p><code>Sidecar</code> 模式可以看做是将应用程序的功能划分为独立的进程运行在同一个调度单元中。<code>Sidecar</code> 模式可以用于抽象与业务逻辑无关的功能，从而降低代码的重复性和复杂性。我们关心的服务观测、监控、日志、配置、服务熔断等功能都可以在 <code>sidecar</code> 容器中实现并部署在同一单元上，比如部署在 <code>Kubernetes</code> 的同一个 <code>Pod</code> 中。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/01.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://apisix.apache.org/blog/2021/12/17/exposure-istio-with-apisix-ingress/</div><p>在 <code>sidecar</code> 模式下，代理容器可以与 <code>Pod</code> 中的应用程序容器共享相同的网络命名空间。网络命名空间是 <code>Linux</code> 内核的结构，它允许容器和 <code>Pod</code> 拥有自己独立的网络堆栈，将容器化应用程序相互隔离，这使得应用程序彼此互不影响，这就是为什么我们可以让尽可能多的 <code>Pod</code> 在 <code>80</code> 端口上运行 <code>Web</code> 应用程序。<code>Sidecar</code> 代理将共享相同的网络命名空间，以便它可以拦截和处理进出应用容器的流量。</p><h2 id="3-Service-Mesh-探索"><a href="#3-Service-Mesh-探索" class="headerlink" title="3. Service Mesh 探索"></a>3. Service Mesh 探索</h2><p>微服务是一种架构风格，它可以将具有单一职责和功能的多个单元以模块化的方式组合起来，形成一个非常复杂的、大型的应用程序。</p><p>第一代微服务依赖于内置的 <code>SDK</code> 实现服务发现、熔断重试等功能（如 <code>Spring Cloud</code>）。从开发的角度来看，这种方式存在很大的不足，因为开发人员需要将 <code>SDK</code> 包含在软件调用堆栈中并最终完全依赖特定的编程语言，更不用说升级/部署成本、敏捷性原则（当 <code>SDK</code> 升级时，应用程序也需要升级）、版本碎片化和较高的学习曲线。即使业务逻辑未发生改变，如果 <code>SDK</code> 需要升级，应用程序也需要更新发布新版本，这就是非业务代码与业务代码耦合的结果。</p><h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><p><code>Service Mesh</code> 位于基础设施层，通过 <code>Sidecar</code> 模式处理服务之间的通信，以透明代理的形式提供安全、快速、可靠的服务间通信。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/02.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://servicemesh.es</div><p>借助 <code>Service Mesh</code>，我们可以将 <code>SDK</code> 中的大部分能力从应用程序中剥离出来，拆解成独立的进程（容器），以 <code>sidecar</code> 的形式进行部署。通过将服务治理能力下沉到基础设施中，微服务只需要做好一件事——专注于业务逻辑，而且会做的越来越专业。</p><p>这样，基础架构团队就可以更加专注于各种通用能力，真正做到自主演进、透明升级，提升整体效率。</p><p><code>Service Mesh</code> 的基础设施层主要分为<strong>控制面</strong>和<strong>数据面</strong>两部分。<code>Istio</code> 和 <code>Linkerd</code> 是两个流行的开源服务网格框架。稍后我们将重点讨论 <code>Istio</code>。</p><p>服务网格在整体架构上比较简单，不过就是在各种服务旁边部署很多用户代理，再加上一套任务管理进程。代理在服务网格中称为数据层或数据面，管理进程称为控制层或控制面。数据面拦截不同服务之间的流量并“处理”它们；控制面协调代理的行为，并提供 <code>API</code> 或命令行工具来进行版本管理，从而实现持续集成和部署。</p><p>服务之间不会通过网络直接进行调用，而是通过本地的 <code>sidecar</code> 代理进行调用，同时 <code>sidecar</code> 代理又代表服务管理请求，封装了服务间通信的复杂性。</p><h2 id="4-Istio-快速入门"><a href="#4-Istio-快速入门" class="headerlink" title="4. Istio 快速入门"></a>4. Istio 快速入门</h2><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/03.png" style="width:100%"><p><code>Istio</code> 是一个开源的服务治理平台，面向云原生场景以 <code>Service Mesh</code> 的形式提供服务，并与 <code>Kubernetes</code> 紧密结合。<code>Istio</code> 提供了负载均衡、服务间鉴权、服务监控和其它一些能力。</p><h3 id="Istio-架构"><a href="#Istio-架构" class="headerlink" title="Istio 架构"></a>Istio 架构</h3><p><code>Istio</code> 的架构分为控制面和数据面。</p><ul><li><strong>数据面</strong>：它由遍布整个网格的 <code>sidecar</code> 代理组成，它与应用服务一起以 <code>sidecar</code> 的形式部署，每个 <code>sidecar</code> 都会接管服务的进出流量，配合控制面完成流量控制等功能；</li><li><strong>控制面</strong>：顾名思义，它在数据面之上，负责控制和管理 <code>sidecar</code> 代理，完成配置分发、服务发现、授权认证等功能。<strong>在架构中设置控制面的优势是可以统一管理数据面。</strong></li></ul><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>下面简单介绍一下 <code>Istio</code> 架构中几个核心组件的主要功能。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/04.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://ssup2.github.io/theory_analysis/Istio_Architecture/</div><h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><p><code>Envoy</code> 是使用 <code>C++</code> 语言实现的高性能代理。 <code>Istio</code> 服务网格将 <code>Envoy</code> 代理作为 <code>sidecar</code> 容器注入到应用程序容器旁边，并拦截服务的所有进出流量，执行不同的功能，例如负载均衡、服务熔断、故障注入和暴露 <code>Prometheus</code> 和 <code>Jeager</code> 收集数据的代理指标等，被注入的代理共同构成了服务网格的<strong>数据面</strong>。</p><h3 id="Istiod"><a href="#Istiod" class="headerlink" title="Istiod"></a>Istiod</h3><p><code>Istiod</code> 是一个控制面组件，它提供服务发现、配置和证书管理功能。 <code>Istiod</code> 采用 <code>YAML</code> 格式编写配置文件，并将其转换为 <code>Envoy</code> 可使用配置格式，然后它将此配置分发到网格中的所有 <code>sidecar</code>。</p><ul><li><p><strong>Pilot</strong>：<code>Pilot</code> 组件的主要作用是将路由规则等配置信息转化为 <code>sidecar</code> 可以识别的内容，发送给数据面。可以简单理解为配置分发器，辅助 <code>sidecar</code> 完成流量控制相关功能；</p></li><li><p><strong>Citadel</strong>：<code>Citadel</code> 是 <code>Istio</code> 中的一个安全组件，它负责证书生成，允许数据面代理之间进行安全的 <code>mTLS</code> 通信；</p></li><li><p><strong>Galley</strong>：<code>Galley</code> 是在 <code>Istio 1.1</code> 版本中新增加的一个组件，目的是解耦 <code>Pilot</code> 和 <code>Kubernetes</code> 等底层平台。它共享了原有 <code>Pilot</code> 的部分功能，主要负责配置的校验、提取和处理功能。</p></li></ul><h3 id="Istio-流量转发"><a href="#Istio-流量转发" class="headerlink" title="Istio 流量转发"></a>Istio 流量转发</h3><p>流量路由分为入站和出站处理流程。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/05.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://istio.io/latest/blog/2022/merbridge/</div><p>入站处理程序作用是将下游流量转发到主应用程序容器，另一方面，出站处理程序监听所有出站流量并将其转发到上游。 <code>Istio</code> 使用一个 <code>Init</code> 容器操作 <code>Pod</code> 网络命名空间中的 <code>iptables</code> 并设置规则，以便将 <code>Pod</code> 的入站/出站数据包传输到 <code>sidecar</code>。</p><p><code>Init</code> 容器与应用容器相比有如下不同：</p><ul><li>它在主容器启动之前开始运行，并一直运行到完成；</li><li>如果有很多 <code>Init</code> 容器，它们将以顺序方式启动运行。</li></ul><p>说到 <code>Service Mesh</code>，我们可能首先想到的就是 <code>Istio</code> + <code>Envoy</code> 构成的 <code>sidecar</code> 模式的 <code>Service Mesh</code> 架构，目前这个架构非常流行；虽然乍一看这个架构没有明显的问题，但仍有几点值得深入考虑：</p><ul><li><strong>性能下降</strong>：代理是一个独立的应用程序，需要特定的资源，例如 <code>CPU</code> 和 <code>内存</code>，<code>Envoy</code> 运行通常需要大约 <code>1G</code> 的内存；</li><li><strong>架构复杂</strong>：需要控制面、数据面、不同应用的规则推送、代理之间的通信安全等；</li><li><strong>运维成本增加</strong>：没有自动化运维工具，就无法部署 <code>sidecar</code>，<code>Service Mesh</code> 的典型解决方案是基于 <code>Kubernetes</code>，能够减少很多工作量。</li></ul><h2 id="5-eBPF-介绍"><a href="#5-eBPF-介绍" class="headerlink" title="5. eBPF 介绍"></a>5. eBPF 介绍</h2><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/06.png" style="width:100%"><p>正如我们已经观察到的情况，使用 <code>sidecar</code> 模式需要在每个服务单元上正确部署一个容器；如果仔细观察，每个节点只有一个内核，在同一个节点上运行的所有容器都共享同一个内核，我们能不能利用它来将部署的 <code>sidecar</code> 代理的数量减少到与节点的数量一致？<code>eBPF</code> 正是用于解决这个问题。</p><p><code>eBPF</code> 是一种内核技术，允许自定义程序在内核中运行，这些运行的程序可以响应数以千计的各种事件，<code>eBPF</code> 程序可以附加到这些事件上，这些事件包括轨迹点、访问或退出各种功能（在内核或用户空间中）或对服务网格很重要的网络数据包。如果我们将一个 <code>eBPF</code> 程序添加到一个内核事件中，它就会被触发，无论是哪个进程触发了这个事件，也无论事件是运行在应用程序容器中还是直接运行在主机上。无论是在可观测性、安全性还是网络，<code>eBPF</code> 驱动的解决方案无需部署 <code>sidecar</code> 就可以检测到应用程序。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/07.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh</div><p><code>2021</code> 年 <code>12</code> 月 <code>2</code> 日，<code>Cilium</code> 项目宣布了 <a target="_blank" rel="noopener" href="https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta/">Cilium Service Mesh</a> 的 <code>Beta</code> 测试计划。基于 <code>eBPF</code> 的 <a target="_blank" rel="noopener" href="https://cilium.io/">Cilium</a> 项目将这种 <strong>Sidecarless</strong> 模型引入到 <code>Service Mesh</code>，以实现 <code>Service Mesh</code> 的大部分 <code>sidecar</code> 代理能力，包括 <code>L7</code> 路由、负载均衡、<code>TLS</code>、访问策略、健康检查、日志记录和链路追踪。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/08.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/</div><p>切换到这种新的模式将会给我们带来什么好处？</p><h3 id="减少-YAML-配置"><a href="#减少-YAML-配置" class="headerlink" title="减少 YAML 配置"></a>减少 YAML 配置</h3><p>在 <code>sidecar</code> 模式中，需要修改每个指定应用程序 <code>Pod</code> 的 <code>YAML</code> 文件来添加 <code>sidecar</code> 容器，这通常是自动化完成的——例如，使用变异的 <code>webhook</code> 在部署每个应用程序 <code>Pod</code> 时注入 <code>sidecar</code>。</p><p>以 <code>Istio</code> 为例，它需要标记 <code>Kubernetes</code> 命名空间和（或） <code>Pod</code> 来定义是否应该注入 <code>sidecar</code>。</p><p>如果出现问题怎么办？如果命名空间或 <code>Pod</code> 没有被正确标记，<code>sidecar</code> 将不会被注入，<code>Pod</code> 也就无法连接到服务网格；更糟糕的是，如果攻击者破坏集群并运行恶意程序，通过服务网格提供的流量观测能力是无法发现的。</p><p>相比之下，在支持 <code>eBPF</code> 的无 <code>sidecar</code> 代理模型中，无需任何额外的 <code>YAML</code> 配置即可检测到 <code>Pod</code>。相反，<code>CRD</code> 用于配置集群内的服务网格，甚至现有的 <code>Pod</code> 无需重新启动也可以成为服务网格的一部分。</p><p>此外，当攻击者试图通过直接在主机上运行程序来绕过 <code>Kubernetes</code> 编排时，<code>eBPF</code> 能够监控并控制此类行为，因为所有这些操作都可以从内核中看到。</p><h3 id="网络效率"><a href="#网络效率" class="headerlink" title="网络效率"></a>网络效率</h3><p>在启用 <code>eBPF</code> 的网络中，数据包可以绕过内核的一些网络堆栈，从而提高性能。我们研究一下如何将它应用到服务网格的数据面。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/09.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/</div><p>在 <code>eBPF</code> 加速和无 <code>sidecar</code> 的服务网格模型中，网络数据包传输的路径要短很多。</p><p>在服务网格的场景下，代理在传统网络中作为 <code>sidecar</code> 运行，数据包到应用程序的路径相当长：入站数据包必须穿过主机 <code>TCP/IP</code> 网络堆栈并通过虚拟网卡连接到 <code>Pod</code> 的网络命名空间。从这开始，数据包必须通过 <code>Pod</code> 的网络堆栈才能到达代理，代理通过环回地址将数据包转发给应用程序。考虑到流量必须经过连接两端的代理，与非服务网格场景下的流量相比，延迟将会显著增加。</p><p>基于 <code>eBPF</code> 的 <code>Kubernetes</code> <code>CNI</code> 实现，例如 <code>Cilium</code>，可以使用 <code>eBPF</code> 程序智能地 <code>hook</code> 内核中的特定点，并使用更直接的路由重定向数据包，这是可以做到的，因为 <code>Cilium</code> 知道所有 <code>Kubernetes</code> 端点和服务的身份，当数据包到达主机时，<code>Cilium</code> 可以将其直接分配给它需要的代理或 <code>Pod</code> 端点。</p><h3 id="网络加密"><a href="#网络加密" class="headerlink" title="网络加密"></a>网络加密</h3><p>服务网格通常用于确保所有应用程序流量都经过身份认证和加密。通过双向 <code>TLS</code> (<code>mTLS</code>)，服务网格代理组件充当网络连接的端点，并与远程端点协商安全 <code>TLS</code> 连接，该连接在不更改应用程序的情况下加密代理之间的通信。</p><p><code>TLS</code> 的应用层实现并不是实现组件之间认证和流量加密的唯一方式，也可以使用 <code>IPSec</code> 或 <code>WireGuard</code> 在网络层进行流量加密，因为它在网络层运行，所以这种加密不仅对应用程序完全透明，而且对代理也完全透明——无论是否存在服务网格，都可以启用它。如果我们使用服务网格的唯一原因是提供加密，我们就可以考虑网络层加密，它不仅更简单，而且还用于验证和加密节点上的所有流量——能够不局限于启用了 <code>sidecar</code> 的程序。</p><h2 id="6-RSocket-Broker"><a href="#6-RSocket-Broker" class="headerlink" title="6. RSocket Broker"></a>6. RSocket Broker</h2><p><code>RSocket</code> 路由代理是使用 <code>RSocket</code> 协议在广泛的应用程序之间进行通信的系统。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/10.png" style="width:100%"><div style="color:#a9a9a9;font-size:14px;text-align:center">https://rsocketbyexample.info/java/</div><p><code>RSocket Broker</code> 的工作原理是：服务调用者（<code>Requester</code>）向 <code>Broker</code> 发起服务调用请求，<code>Broker</code> 将请求转发给服务提供者（<code>Responder</code>），<code>Broker</code> 最终将 <code>Responder</code> 的处理结果返回给服务调用者。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/11.png" style="width:100%"><p>当一个服务提供者应用程序启动时，它会主动与 <code>Broker</code> 创建一个 <code>TCP</code> 长连接，然后告诉 <code>Broker</code> 它可以提供的服务列表。</p><p>当一个服务消费者应用程序启动时，它同样会与 <code>Broker</code> 创建一个 <code>TCP</code> 长连接。当消费者应用程序想要调用一个远程服务时，服务消费者将服务调用请求封装为消息（用唯一的消息 <code>ID</code> 标识）发送给 <code>Broker</code>。<code>Broker</code> 收到消息后，根据携带的元数据信息解析出需要调用的服务，然后在内部服务路由表中查找可以调用的服务。<br>服务提供者处理请求后，将处理结果封装为消息返回给 <code>Broker</code>。<code>Broker</code> 根据消息 <code>ID</code> 将返回的消息转发给服务调用者，发起请求的消费者响应消息内容并执行相应的业务逻辑。</p><p>这种基于 <code>Broker</code> 的消息通信方式具有以下优点：</p><ul><li>不需要第三方健康检查，因为我们知道连接何时建立；</li><li>无端口监听：服务提供者不再监听端口，与 <code>HTTP REST API</code> 和 <code>gRPC</code> 完全不同，它更加安全；</li><li>通信透明：服务调用者和服务提供者无需感知对方的存在；</li><li>流量控制：如果服务提供者压力过大，<code>Broker</code> 会自动将消息转发给其他服务提供者（智能负载均衡），可以通过租约来实现；</li><li>服务注册和发现：无需 <code>Eureka</code>、<code>Consul</code>、<code>ZooKeeper</code> 等第三方注册中心，降低基础设施依赖成本；</li><li>安全：<code>Broker</code> 会验证服务提供者和服务消费者的访问权限，只需要在 <code>Broker</code> 上部署 <code>TLS</code> 支持即可保证通信通道的安全。</li></ul><h3 id="没有免费的午餐"><a href="#没有免费的午餐" class="headerlink" title="没有免费的午餐"></a>没有免费的午餐</h3><p><code>Broker</code> 也有一些缺点，由于服务提供者和服务消费者双方之间不是直接进行通信，所以性能会有所下降；此外，所有通信流量都需要通过 <code>Broker</code> 转发，因此也可能存在网络瓶颈，但这可以通过集群部署和 <code>Broker</code> 的高可靠性来解决。</p><h2 id="7-通过-RSocket-Broker-进行服务治理"><a href="#7-通过-RSocket-Broker-进行服务治理" class="headerlink" title="7. 通过 RSocket Broker 进行服务治理"></a>7. 通过 RSocket Broker 进行服务治理</h2><p><code>Istio</code> 作为 <code>Service Mesh</code> 的解决方案，其实很难在数据中心之外应用。那物联网设备呢？给每个手机都安装 <code>sidecar</code> 吗？这就是 <code>RSocket</code> 代理发挥作用的地方。</p><p><code>RSocket</code> 路由代理可用于实现服务网格。在下面的方案中，没有运行的 <code>sidecar</code>，也没有其它额外的进程。</p><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2023/06-Exploring-Service-Mesh-In-Depth-Study/12.png" style="width:100%"><p>下面是两种架构方案的典型特征对比：</p><ul><li>基础设施层：一个是 <code>sidecar</code> 代理 + 控制面，另一个是集成了控制面功能的中心化 <code>Broker</code>；</li><li>集中管理：集中化会让管理更全面，比如 <code>Logging</code>、<code>Metrics</code> 等；</li><li>通信协议：<code>RSocket</code> 方案的一个缺点是应用程序之间必须使用 <code>RSocket</code> 通信协议；</li><li>应用程序或设备访问：并非所有设备都可以安装代理，主要有几个原因：设备和系统本身不支持，比如物联网设备，这是基于 <code>RSocket</code> 的方案具有巨大优势的地方；</li><li>增加运维成本：管理一个由 <code>10</code> 台服务器组成的 <code>RSocket Broker</code> 集群和管理 <code>10K</code> 个 <code>Proxy</code> 成本实例是不一样的；</li><li>效率：<code>RSocket</code> 协议性能比 <code>HTTP</code> 高 <code>10</code> 倍；</li><li>安全性：<code>RSocket</code> 的安全实现更简单。<code>Broker</code> 主要是用 <code>TLS</code> + <code>JWT</code> 实现，不使用 <code>mTLS</code>，不需要证书管理；同时，借助 <code>JWT</code> 的安全模型，很容易实现更细粒度的权限控制，使用 <code>RSocket</code> 代理方案，可以减少攻击面；</li><li>网络和基础设施依赖：<code>RSocket Broker</code> 相对于 <code>Istio</code> 的一大优势就是不依赖 <code>Kubernetes</code>，虽然 <code>Istio</code> 也声称不依赖 <code>Kubernetes</code>，但是在 <code>Kubernetes</code> 之外部署和管理 <code>sidecar</code> 代理会很麻烦，而 <code>RSocket Broker</code> 可以部署在任何地方。</li></ul><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>服务治理是微服务时代一个重要性不断增长的话题。在本文中我们通过 <code>Istio</code>、<code>eBPF</code> 和 <code>RSocket Router</code> 技术研究了实现服务治理的不同解决方案。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/">https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/</a></li><li><a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/rsocket-spring-cloud-gateway/">https://www.infoq.com/presentations/rsocket-spring-cloud-gateway/</a></li><li><a target="_blank" rel="noopener" href="https://www.alibabacloud.com/blog/a-brief-on-rsocket-and-reactive-programming_598219">https://www.alibabacloud.com/blog/a-brief-on-rsocket-and-reactive-programming_598219</a></li><li><a target="_blank" rel="noopener" href="https://www.slideshare.net/Pivotal/weaving-through-the-mesh-making-sense-of-istio-and-overlapping-technologies">https://www.slideshare.net/Pivotal/weaving-through-the-mesh-making-sense-of-istio-and-overlapping-technologies</a></li><li><a target="_blank" rel="noopener" href="https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/">https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/</a></li><li><a target="_blank" rel="noopener" href="https://kknews.cc/code/kk5bqn8.html">https://kknews.cc/code/kk5bqn8.html</a></li><li><a target="_blank" rel="noopener" href="https://blog.birost.com/a?ID=00900-415484c9-b8a9-4762-8da9-daf675dcd626">https://blog.birost.com/a?ID=00900-415484c9-b8a9-4762-8da9-daf675dcd626</a></li><li><a target="_blank" rel="noopener" href="https://knner.wang/2019/12/27/ServiceMesh-Istio-Series--microservice-kubernetes-istio-relation.html">https://knner.wang/2019/12/27/ServiceMesh-Istio-Series--microservice-kubernetes-istio-relation.html</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd818114ab4b">https://www.jianshu.com/p/dd818114ab4b</a></li><li><a target="_blank" rel="noopener" href="https://knner.wang/2019/12/27/ServiceMesh-Istio-Series--microservice-kubernetes-istio-relation.html">https://knner.wang/2019/12/27/ServiceMesh-Istio-Series--microservice-kubernetes-istio-relation.html</a></li><li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/q65ddirtdsbf*e6ki2p4">https://www.infoq.cn/article/q65ddirtdsbf*e6ki2p4</a></li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="https://dongzl.github.io">董宗磊的博客</a> 版权所有。如若转载，请注明出处：董宗磊的博客（<a href="https://dongzl.github.io/2023/03/13/06-Exploring-Service-Mesh-In-Depth-Study/">https://dongzl.github.io/2023/03/13/06-Exploring-Service-Mesh-In-Depth-Study/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2023/03/10/05-MySQL-Lower-Case-Table-Name-Problems/" title="表不存在：MySQL 中 lower_case_table_names 问题探究"><i class="iconfont icon-prev"></i>表不存在：MySQL 中 lower_case_table_names 问题探究</a></div><div class="post__prev post__prev--right"><a href="/2023/03/18/07-Dealing-With-Too-Many-Connections-Error-in-MySQL-8/" title="MySQL 8 中如何处理 Too Many Connections 错误">MySQL 8 中如何处理 Too Many Connections 错误<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">记录自己作为程序员的技术成长经历，程序员是个特殊的职业，一旦选择这个职业就要时刻保持学习的热情，如果你也喜欢我的博客，欢迎订阅 RSS。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="block-list-count">5</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">架构设计</a><span class="block-list-count">29</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="block-list-count">25</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/web%E5%BC%80%E5%8F%91/">web开发</a><span class="block-list-count">11</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/java%E5%BC%80%E5%8F%91/">java开发</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Go%E8%AF%AD%E8%A8%80/">Go语言</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2023/12/19/26-Asynchronous-API-Design-Best-Practices-Server-Sent-Event/" title="异步 API 设计最佳实践：用于实时通信的服务端事件发送 (SSE)"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/async_vs_sync.png" alt="异步 API 设计最佳实践：用于实时通信的服务端事件发送 (SSE)"></div><div class="item__info"><h3 class="item__title">异步 API 设计最佳实践：用于实时通信的服务端事件发送 (SSE)</h3><span class="item__text">2023-12-19</span></div></a></li><li class="latest-post-item"><a href="/2023/11/18/25-Difference-Between-Forward-Proxy-Reverse-Proxy-System-Design/" title="系统设计中正向代理和反向代理的差异"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/forward_reverse_proxy_v2.png" alt="系统设计中正向代理和反向代理的差异"></div><div class="item__info"><h3 class="item__title">系统设计中正向代理和反向代理的差异</h3><span class="item__text">2023-11-18</span></div></a></li><li class="latest-post-item"><a href="/2023/09/23/24-Scaling-Microservices-Strategies-Handling-Increased-Demand-Efficiency/" title="微服务扩展：以 99% 的处理效率来应对不断增长的需求"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/scaling_microservices.png" alt="微服务扩展：以 99% 的处理效率来应对不断增长的需求"></div><div class="item__info"><h3 class="item__title">微服务扩展：以 99% 的处理效率来应对不断增长的需求</h3><span class="item__text">2023-09-23</span></div></a></li><li class="latest-post-item"><a href="/2023/08/27/23-Difference-Between-SAGA-CQRS-Design-Patterns-Microservices/" title="微服务中 SAGA 和 CQRS 设计模式的差异？"><div class="item__cover"><img src="https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/cover/SAGA_vs_CQRS.png" alt="微服务中 SAGA 和 CQRS 设计模式的差异？"></div><div class="item__info"><h3 class="item__title">微服务中 SAGA 和 CQRS 设计模式的差异？</h3><span class="item__text">2023-08-27</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/AQS/">AQS</a></li><li class="tag-item"><a class="tag-link" href="/tags/ActiveMQ/">ActiveMQ</a></li><li class="tag-item"><a class="tag-link" href="/tags/Apache/">Apache</a></li><li class="tag-item"><a class="tag-link" href="/tags/BloomFilter/">BloomFilter</a></li><li class="tag-item"><a class="tag-link" href="/tags/CQRS/">CQRS</a></li><li class="tag-item"><a class="tag-link" href="/tags/Calcite/">Calcite</a></li><li class="tag-item"><a class="tag-link" href="/tags/ClickHouse/">ClickHouse</a></li><li class="tag-item"><a class="tag-link" href="/tags/CountDownLatch/">CountDownLatch</a></li><li class="tag-item"><a class="tag-link" href="/tags/Docker/">Docker</a></li><li class="tag-item"><a class="tag-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-item"><a class="tag-link" href="/tags/Full-GC/">Full GC</a></li><li class="tag-item"><a class="tag-link" href="/tags/Go/">Go</a></li><li class="tag-item"><a class="tag-link" href="/tags/GraphQL/">GraphQL</a></li><li class="tag-item"><a class="tag-link" href="/tags/Guava/">Guava</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hibernate/">Hibernate</a></li><li class="tag-item"><a class="tag-link" href="/tags/Istio/">Istio</a></li><li class="tag-item"><a class="tag-link" href="/tags/JPA/">JPA</a></li><li class="tag-item"><a class="tag-link" href="/tags/JSON/">JSON</a></li><li class="tag-item"><a class="tag-link" href="/tags/JVM/">JVM</a></li><li class="tag-item"><a class="tag-link" href="/tags/JWT/">JWT</a></li><li class="tag-item"><a class="tag-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-item"><a class="tag-link" href="/tags/Linux/">Linux</a></li><li class="tag-item"><a class="tag-link" href="/tags/Lock/">Lock</a></li><li class="tag-item"><a class="tag-link" href="/tags/Lombok/">Lombok</a></li><li class="tag-item"><a class="tag-link" href="/tags/MAT/">MAT</a></li><li class="tag-item"><a class="tag-link" href="/tags/Map/">Map</a></li><li class="tag-item"><a class="tag-link" href="/tags/Microservices/">Microservices</a></li><li class="tag-item"><a class="tag-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-item"><a class="tag-link" href="/tags/OAuth/">OAuth</a></li><li class="tag-item"><a class="tag-link" href="/tags/Performance-Schema/">Performance Schema</a></li><li class="tag-item"><a class="tag-link" href="/tags/REST/">REST</a></li><li class="tag-item"><a class="tag-link" href="/tags/RSocket/">RSocket</a></li><li class="tag-item"><a class="tag-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-item"><a class="tag-link" href="/tags/Reactor/">Reactor</a></li><li class="tag-item"><a class="tag-link" href="/tags/Redis/">Redis</a></li><li class="tag-item"><a class="tag-link" href="/tags/Rust/">Rust</a></li><li class="tag-item"><a class="tag-link" href="/tags/SAGA/">SAGA</a></li><li class="tag-item"><a class="tag-link" href="/tags/SAML/">SAML</a></li><li class="tag-item"><a class="tag-link" href="/tags/SPI/">SPI</a></li><li class="tag-item"><a class="tag-link" href="/tags/SSE/">SSE</a></li><li class="tag-item"><a class="tag-link" href="/tags/Security/">Security</a></li><li class="tag-item"><a class="tag-link" href="/tags/Service-Mesh/">Service Mesh</a></li><li class="tag-item"><a class="tag-link" href="/tags/ShardingSphere/">ShardingSphere</a></li><li class="tag-item"><a class="tag-link" href="/tags/Singleton/">Singleton</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring/">Spring</a></li><li class="tag-item"><a class="tag-link" href="/tags/Spring-Data-JPA/">Spring Data JPA</a></li><li class="tag-item"><a class="tag-link" href="/tags/TestContainers/">TestContainers</a></li><li class="tag-item"><a class="tag-link" href="/tags/Thread/">Thread</a></li><li class="tag-item"><a class="tag-link" href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a></li><li class="tag-item"><a class="tag-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-item"><a class="tag-link" href="/tags/Zero-Copy/">Zero Copy</a></li><li class="tag-item"><a class="tag-link" href="/tags/ZooKeeper/">ZooKeeper</a></li><li class="tag-item"><a class="tag-link" href="/tags/eBPF/">eBPF</a></li><li class="tag-item"><a class="tag-link" href="/tags/gRPC/">gRPC</a></li><li class="tag-item"><a class="tag-link" href="/tags/hexo/">hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/maven/">maven</a></li><li class="tag-item"><a class="tag-link" href="/tags/synchronized/">synchronized</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/">两阶段提交</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">主从复制</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90/">事件溯源</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E4%BA%8B%E5%8A%A1/">事务</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%BC%B9%E6%80%A7/">弹性</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%80%BB%E7%BB%93/">总结</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">数学公式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/">正向代理</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%B2%89%E6%80%9D%E5%BD%95/">沉思录</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E7%BD%91%E5%85%B3/">网关</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">设计原则</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B0%83%E4%BC%98/">调优</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>dongzonglei@apache.org</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/theme/qrcode.jpeg" alt="logo" title="董宗磊的博客"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://mrdear.cn/" title="mrdear" target="_blank">mrdear</a></li><li class="list-item"><a href="https://tech.meituan.com/" title="美团技术团队" target="_blank">美团技术团队</a></li><li class="list-item"><a href="https://coolshell.cn/" title="酷 壳–CoolShell" target="_blank">酷 壳–CoolShell</a></li><li class="list-item"><a href="https://tech.youzan.com/" title="有赞技术团队" target="_blank">有赞技术团队</a></li><li class="list-item"><a href="https://insights.thoughtworks.cn" title="Thoughtworks洞见" target="_blank">Thoughtworks洞见</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">大V博客</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://draveness.me/" title="draveness" target="_blank">draveness</a></li><li class="list-item"><a href="http://www.ruanyifeng.com/home.html" title="阮一峰的个人网站" target="_blank">阮一峰</a></li><li class="list-item"><a href="https://blog.devtang.com/" title="唐巧的博客" target="_blank">唐巧的博客</a></li><li class="list-item"><a href="https://www.hollischuang.com/" title="Hollis" target="_blank">Hollis</a></li><li class="list-item"><a href="http://coder5.cn/" title="武哥漫谈IT" target="_blank">武哥漫谈IT</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="hexo-theme-skapp" target="_blank">hexo-theme-skapp</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/dongzl" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:dongzonglei@apache.org" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Service Mesh","Istio","eBPF","RSocket"],gitalk=new Gitalk({clientID:"791785cb3bf7b9b5f1ea",clientSecret:"a73d2380b7dba08575e0190989ef017e480c20c9",repo:"dongzl.github.io",owner:"dongzl",admin:["dongzl"],labels:tags,id:new Date(1678737802e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/haruto.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0},react:{opacity:1},log:!1})</script></body></html>